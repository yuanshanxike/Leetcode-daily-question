/**
 * 对于从第 i 个加油站到第 i+1 个加油站，无论能不能到达，油量波动 Δ = gas[i] - cost[i]。（从每个站出发的油量波动值不会受到起点变更的影响）
 * 从左往右计算每个 Δ, 建立一个二维坐标轴，横坐标为加油站编号，纵坐标为从当前加油站到达下一个加油站时的剩余油量。横坐标每次向右移动一位，纵坐标加上相应的 Δ.
 * 开始时油量为 0. 为方便计算，从左往右遍历 gas 和 cost，将计算的 的 Δ 绘制成二维坐标折线图。起点为 (-1, 0) 表示从第 0 个加油站出发，终点为 (n - 1, ΣΔ) 表示从最后一个加油站(n - 1)出发回到第一个加油站还剩余 ΣΔ L油。
 * 如果能完整走完一圈，最终的 ΣΔ 一定是 >0 的，表示总油量能 cover 住总路程。
 * 在能走完一圈的前提下，通过找到折线图中的最低点来确定起始点的位置。
 * 因为如果把油量最低点所去往的下一站作为起始点时，从这点出发时的油量一定为 0，又因为它是折线图中的最低点，其余点的纵坐标一定 >= 0. 相当是于把整个折线图的二维坐标系向上平移了最低点纵坐标的绝对值距离。
 * 折线图中的每个点，通过 Δ 的前缀和进行计算。
 * @param gas 
 * @param cost 
 */
function canCompleteCircuit(gas: number[], cost: number[]): number {
    const n = gas.length
    let res = 0 // 滚动计算前缀和
    let minRes = 1e9
    let ans = -1
    for (let i = 0; i < n; i++) {
        res = gas[i] - cost[i] + res
        if (res < minRes) {
            minRes = res
            ans = (i + 1) % n  // 因为折线图中的点表示：从该站点去往下一站点后剩余的油量。所以在确定起点时需要用油量最低点的位置 +1
        }
    }
    if (res < 0) return -1
    return ans
};

console.log(canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2]))
console.log(canCompleteCircuit([2,3,4], [3,4,3]))