/**字符串能否构成回文，和所构成字符的奇偶数量是密切相关的。
 * 奇 + 奇 = 偶， 偶 + 偶 = 偶， 奇 + 偶 = 奇
 * 让 奇 == 1，偶 == 0。可以将上式转化为 异或运算：
 * 1 ⊕ 1 = 0， 0 ⊕ 0 = 0， 1 ⊕ 0 = 1
 * 换成减法同样是成立的：
 * 偶-奇 = 奇，偶-偶 = 偶，奇-奇  = 偶，奇-偶 = 奇
 * 0 - 1 = 1， 0 - 0 = 0， 1 - 1 = 0， 1 - 0 = 1
 * 减法也是满足异或运算的。
 * 
 * 所以可以直接使用“前缀异或和”来保存字符串前缀中各元素的奇偶性，
 * 通过任意的两个前缀，也就能够计算出任意的区间中各个字符的奇偶性。
 * 
 * 分类讨论(设字符串的两个边界的下标分别是 i + 1 和 j，且 i + 1 <= j,；pre[i] 是一个10位的二进制数，每一位分别表示s 0~i 位的“前缀异或和”)：
 * ① 如果 s[i + 1] 到 s[j]的字符串长度为偶数，要使得这个字串可以变成回文串，串中每个字符出现次数应该都是偶数，则 pre[j] ⊕ pre[i] = 0，也就是说 pre[i] == pre[j];
 * ② 如果 s[i + 1] 到 s[j]的字符串长度为奇数，要使得这个字串可以变成回文串，串中只应该有一个字符的出现次数是奇数，其余字符的出现次数均为偶数。
 * 也就是需要满足 pre[j] ⊕ pre[i] = 2^k，等价于 pre[j] == pre[i] ⊕ 2^k。其中 2^k是只有一个 1 的二进制数，对应恰好一个数字出现次数是奇数的情况。
 * (为了能够计算 pre[i] (从 0 到 i 的前缀异或和)，需要让 pre[-1] = 0)
 * 
 * 从左到右遍历 j，我们需要能满足条件的 i 是越小越好。也就是说，其实没必要重复枚举去计算各个区间的“异或和”，
 * 对于当前遍历位置 j 对应的 pre[j]，分类讨论：① 区间元素数量是偶数时，符合可以交换成回文子串的左边界对应“前缀
 * 异或和”一定等于 pre[j]；② 区间元素数量是奇数时，符合可以交换成回文字串的左边界对应“前缀异或和”一定等于 pre[j] ⊕ 2^k，
 * 其中 k 的取值范围是 [0, 9]，枚举 10 个 2^k 可能的值与 pre[j] 的异或结果，找到最靠左的 i 就是最长区间。
 * 最后，取 ① 和 ② 中最长的区间作为当前 j 为右边界下最长子区间。遍历完 s 就能得到答案。
 * 
 * 对于任意 pre[j]，我们希望能够记录下其出现的最左端位置，所以可以使用一个 hashMap 或 array 叫做 pos，通过 pos[pre[j]] = i，
 * 来存储最左端（首次出现）的位置。而且也不需要 pre[] 数组来记录“前缀异或和”了，只需一个 pre 变量来记录当前的“前缀异或和”就可以满足需求。
 */
function longestAwesome(s: string): number {
    const n = s.length
    let pre = 0
    let ans = 0
    const D = 10 // '0'~'9'
    const pos = Array(1 << D).fill(n) // 数组元素为 n 表示代表奇偶性的二进制还没有对应的位置记录（也就是构成不了能交换成回文的字串）。作为左边界被减去时，也会使得结果为负数，不会影响计算正确的值
    pos[0] = -1 // pre[-1] = 0
    for (let i = 0; i < n; i++) {
        const c = s[i]
        pre ^= 1 << +c // 前缀异或和
        ans = Math.max(ans, i - pos[pre])  // 偶数情况
        for (let k = 0; k < D; k++) {  // 奇数情况
            ans = Math.max(ans, i - pos[pre ^ (1 << k)])
        }
        if (pos[pre] == n) { // 没有最左端记录的 pre 值，要把其最左端记录为当前位置
            pos[pre] = i
        }
    }
    return ans
};

console.log(longestAwesome('3242415'))  // 5
console.log(longestAwesome('12345678')) // 1
console.log(longestAwesome('213123'))   // 6
console.log(longestAwesome('00'))       // 2