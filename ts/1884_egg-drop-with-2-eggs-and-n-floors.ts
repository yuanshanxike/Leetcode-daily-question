/**
 * 具体推到过程参考 Leetcode 877，本题是其的一个子问题.
 * 特别地，当只有两枚鸡蛋可用时，从后往前，按照自然序列(不含0)累加去确认扔鸡蛋的楼层(倒序楼层)可以很好地符合“两侧操作次数均分”原则。
 * 可以这么理解：
 * 第一个蛋肯定要在一个比较高的楼层丢下，因为‘搏一搏单车变摩托’，如果成功了就可以跳过很多层一定不会把蛋摔碎的楼层，赚到了次数。
 * 如果这个层数蛋没有碎，就可以把更高的楼层看成是新的一栋楼，依然会选择一个较高的楼层去丢蛋去‘搏一搏’。
 * 因为我们不知道 f 的确切数值，也就是说不知道从自己所选的楼层扔蛋到底是会碎了还是不碎。
 * 所以每次选择楼层（当还有两枚蛋时），需要考虑碎或不碎所对应的最坏情况，也就是求两种情况对应的最坏情况的所需最小操作次数的最大值。
 * 那么每次准备扔蛋时，所选的楼层应该尽量确保碎或不碎所对应的最坏情况的最小操作次数是一致的。
 * 因为每次扔蛋后，都可以把下次选择的连续剩余楼层看成一栋新楼，且楼层数量太多的话不方便思考。
 * 不妨从仅有 1 层的楼开始思考，由小到大推算出 n 层楼时该如何决策：
 * ① 如果只有一层，直接从一层扔蛋就能找到 f ∈ [0, 1];
 * ② 如果有两层，每层尝试扔一次能够确定 f；
 * ③ 如果有三层，考虑第一次扔蛋时能够将楼层划分成两个区间，使得两个区间中确认 f 所需的最小次数相同：
 * 首先在第二层扔，如果碎了，还剩一个蛋，在第一层扔出后可以确认结果；如果没碎，捡回来还剩两个蛋，在第三层扔出后可以确认结果。
 * 这里已经出现了左右次数相等的区间，定义持有两个蛋扔出的层数为区间的开始，那么有三层的情况下，楼层按区间划分就是 {1, 2🔺}, {3🔺}.
 * 2 和 3 是区间开始的位置，如果下层的区间中扔的蛋没碎，就可以直接向上移动一个区间，从新区间开始的位置(区间的最高楼层)，开始尝试扔蛋；
 * 如果在区间开始的位置扔蛋结果是碎了，可以确认 f 确切的位置就在这个区间中的更低位置，那仅剩的最后一枚蛋就需要从这个区间的最底层开始，逐层尝试任蛋，就能确认 f 的确切位置。
 * 那么，对于每一个区间来说，确认 f 确切值潜在的最多次数是 区间长度 - 1 (不包括区间起始位置的 1 次扔蛋操作，那只是得到了一个 f 的近似值).
 * ④ 我们可以接着构造新的区间，以增加楼层数，为了贯彻“每次选择的楼层的摔蛋结果对应的次数相同”原则，新区间长度 - 1 就应该 = 现存区间数 2.
 * 于是构造出总共 6 层的楼，划分区间为 {1, 2, 3🔺}, {4, 5🔺}, {6🔺}. 选择第 3 层为第一次摔蛋的楼层，再根据以上规则去确定 f 的确切值，最坏情况只需要 3 次.
 * 以开始楼层 3 为根，之后各种情况的下的操作为路径，其他楼层为子节点画一棵树是这样的：
 *     3🔺
 *    / \
 *   1   5🔺
 *  /   / \
 * 2   4   6🔺
 * 
 * 仔细观察这棵树，从根节点到每个叶子节点（最坏情况对应的次数）的距离是相等的，也就是说这棵树的每个叶子节点的高度都相同。
 * 那么接下来，还可以继续在这棵树的左上部分添加 4 个节点，变为 10 层的楼，同样满足每个叶子节点高度相同：
 *       4🔺
 *      / \
 *     1   7🔺
 *    /   / \
 *   2   5   9🔺
 *  /   /   / \
 * 3   6   8   10🔺
 * 
 * 所以等得出结论：用两枚鸡蛋测出确切 f 值，可以从后往前(顶层到底层)用从 1 开始的自然序列分组构建，最小操作次数即为组数。
 * 
 * 对于最后一个分组数量凑不满的情况，树的高度(最坏情况下的次数)也不会继续变小(比如对树进行旋转操作)。
 * 
 * 那么直接可以用等差数列求和公式在 O(1) 的时间复杂度下计算得出。
 * (x + 1) * x / 2 >= n
 * => x^2 + x - 2n >= 0
 * => x >= ( -1 + √(1 - (4 * (-2n))) ) / 2  （排除一个负数根）
 * @param n 
 */
function twoEggDrop(n: number): number {
    return Math.ceil((-1 + Math.sqrt(1 + 8 * n)) / 2)
};

console.log(twoEggDrop(2))
console.log(twoEggDrop(100))