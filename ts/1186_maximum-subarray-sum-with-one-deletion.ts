/**
 * 与 53_maximum-subarray 类似，可以直接套用那样的 dp 思路进行求解（新增加一个数组维度表示当前第 i 个元素是否被跳过）：
 * 定义：dp[i][0/1][0/1] 表示只考虑 arr 中前 i 个元素时，选择第 i 项元素(1) 和 不选第 i 项元素(0) 时，非空连续子数组的最大和。*第三个维度表示是(0)否(1)还能跳过当前数字;
 * 在第三个维度中，0 表示跳过，1 表示不跳过。
 * 最多只有一次跳过机会，所以第三个维度可以从 1 变为 0，但不能从 0 变为 1。
 * 可以知道初始边界值：dp[0][1][1] = arr[0], dp[0][1][0] = 0, , dp[0][0][1] = dp[0][0][0] = 0;
 * 状态转移方程：
 * dp[i + 1][0][0] = max(dp[i][0][0], dp[i][1][0], dp[i][0][1], dp[i][1][1])   // 不选第 i + 1 个数字时，其值等于选(跳过和不跳)和不选(跳过和不跳过都没有影响，因为根本没选它)第 i 个数字四(或者说 3)种情况中的最大值
 * dp[i + 1][0][1] = dp[i + 1][0][0] // 第 i 个元素没选时，没有跳过不跳过一说，所以和 dp[i][0][0] 相同，直接赋值即可
 * dp[i + 1][1][1] = max(dp[i][1][1] + arr[i + 1], arr[i + 1]) // 选第 i + 1 个元素时，其值等于选了前一个元素（和前面的元素连续，且前面的元素不能被跳过(第三个维度不能为 0)，因为我们此时计算的前提是还没有跳过任何元素）的和加上第 i + 1 个元素的值，与第 i 个元素没有被选（前面的元素都没有被选）且第 i + 1 个元素作为第一个被选中的元素
 * dp[i + 1][1][0] = max(dp[i][1][0] + arr[i + 1], dp[i + 1][1][1] - arr[i + 1])  // 选了第 i + 1 个元素，且唯一的一次跳过机会已被使用，对应着有两种情况：1、前面已被使用（之前已使用了跳过机会的元素和 dp[i][1][0] 加上第 i + 1 个元素）；2、在第 i + 1 个元素上被使用（上面计算的未跳过的情况 dp[i + 1][1][1] 减去第 i + 1 个元素本身）
 * 
 * *这算是比较简单粗暴的套用动态规划思想的方法，实际还有很多可以优化的空间，有更简单的思维模型。
 * @param arr 
 */
function maximumSum(arr: number[]): number {
    const n = arr.length
    const dp = Array.from({ length: n }, () => [[0, 0], [0, 0]])
    dp[0][0][0] = 0, dp[0][0][1] = 0, dp[0][1][0] = 0, dp[0][1][1] = arr[0]
    let maxElement = arr[0]  // 需要保证连续子数组非空，也就是即使所有的元素都是负数，也至少需要选择一个。因此可以记录最大元素，都为负数时就只选它
    for (let i = 1; i < n; i++) {
        dp[i][0][0] = Math.max(dp[i - 1][0][0], dp[i - 1][1][0], dp[i - 1][0][1], dp[i - 1][1][1])
        dp[i][0][1] = dp[i][0][0]
        dp[i][1][1] = Math.max(dp[i - 1][1][1] + arr[i], arr[i])
        dp[i][1][0] = Math.max(dp[i - 1][1][0] + arr[i], dp[i][1][1] - arr[i])
        maxElement = Math.max(maxElement, arr[i])
    }
    return maxElement < 0 ? maxElement : Math.max(dp[n - 1][0][0], dp[n - 1][1][1], dp[n - 1][1][0])
};

console.log(maximumSum([1,-2,0,3]))
console.log(maximumSum([1,-2,-2,3]))
console.log(maximumSum([5,-2,-2,5]))
console.log(maximumSum([5,-2,-2,5,-1]))
console.log(maximumSum([-1,-1,-1,-1]))