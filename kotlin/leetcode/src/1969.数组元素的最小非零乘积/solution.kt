package source.`1969`.数组元素的最小非零乘积

class Solution {
    /**
     * 根据 示例3 中的交换方式的启发，可以知道：
     * 要使得除0以外的相同位数的二进制数组的非零乘积最小。
     * 对于数组中的任意两个元素 x 和 y，我们要尽可能使得交换后，
     * 能使得其中一个的值为 1，这样可以避免二进制进位，
     * 使得这两个数的乘积变小，进而也可以使得所有数的乘积变小。
     *
     * 而且对应位相同的 bit （相同的 0 或 1）交换没有任何意义，
     * 所以我们会找彼此间对应位(bit)不同的数字进行位交换，比如：
     * 010 和 101 （最右边的一位不能交换，题目要求非零乘积）
     * 且所有位都交换也没意义，上面例子都交换的结果还是 101 和 010 (还是这两个数相乘，只不过交换了位置)
     * 所以对于这两个数，进行交换(以使得乘积变小为目的)的话只能是 110 和 001。
     * 将其中一个因子稍微变大，另一个变为 1，可以使得非零乘积最小。
     * 上面这种方法,不妨这么理解:
     * 对于任意两个二进制数，相对于的位置的 bit 任意交换后，交换后这两个数的和是不变的。（因为根据二进制加法，对应位置相加的 bit 是没有变化的）
     * 那么我们可以把两数和理解为矩形的 周长，而两数积理解为矩形的 面积；
     * 那么在周长相同的情况下，矩形越矮(或窄)的话面积越小。
     *
     * 对于位长度为 p 的所有二进制数(除了0)，可以产生 C(p, 1) + C(p, 2) + ... + if (⌊p/2⌋ * 2 == p) C(p, ⌊p/2⌋) / 2 else C(p, ⌊p/2⌋) 对这样每位相反的二进制数。
     * 除了这些对之外，还有一个每一位(bit)都是1的二进制数。
     * 这些对都可以交换成 111..10 和 000..01 这样的一个 2^p - 2 和 1 这样的对，
     * 那么它们的乘积就是 2^p - 2。
     * 对于 p位的二进制数 和 p+1位的二进制数，可以用动态规划的思想来看待这个问题。
     * p+1位的二进制数，相当于在 p位的所有二进制数的基础上再添加 1 bit 的数据，这个 bit 可能是 0 或 1，所以相当于 p+1 位的二进制数的数量在 p 位二进制数的数量的基础的规模上又扩大了 1 倍。
     * 而对于每种长度的二进制数，我们都要把 0 给去除，所以p位二进制数的规模为 2^p - 1，
     * 而所以p+1位的二进制数中，有 2^p - 1 对乘积为 2^(p+1) - 2 == (2^p - 1) * 2 的对；
     * 所以再考虑上p+1位全是1的二进制数，最终的乘积就是 (2^(p+1) - 2)^(2^p - 1) * (2^(p+1) - 1).
     *
     * 对于p位二进制数，写成 (2^p - 2)^(2^(p-1) - 1) * (2^p - 1)，
     * (2^p - 2)^(2^(p-1) - 1) 这种某个数的质数次方，需要通过快速幂来实现
     *
     * 注意：直接计算一定会溢出，需要使用 mod 运算发展进行展开后分别计算
     */
    fun minNonZeroProduct(p: Int): Int {
        val base: Long = 1L.shl(p)/*2^p*/ - 2
        val pow: Long = 1L.shl(p - 1)/*2^(p-1)*/ - 1
        return safeMultMod(binpow(base, pow), base + 1).toInt()
    }

    private fun binpow(x: Long, n: Long): Long {
        var pow = n
        var powX = x
        var res = 1L
        while (pow > 0) {
            if (pow and 1L == 1L) res = safeMultMod(res, powX)
            powX = safeMultMod(powX, powX)
            pow = pow.shr(1)
        }
        return res
    }

    /**
     * 乘法取余运算规则
     */
    private fun safeMultMod(x: Long, y: Long): Long = (x % MOD) * (y % MOD) % MOD

//    private operator fun Long.times(another: Long): Long = (this % MOD) * (another % MOD) % MOD
}

private const val MOD = 1_000_000_007L