namespace L1017;

public class Solution {
    /// <summary>
    /// 首先，对于正整数的(-2)进制表示，位数一定是奇数(1, 3, 5, ...)；
    /// 因为偶数位数表示的一定是负整数，所以能表示的正整数是 Int（排除符号位还剩 31 位，int.MaxValue/2 > 10^9） 的一半。
    /// 1bit 时比较特殊，它能表示的数字范围和2进制没有区别；
    /// 3bit 能表示4个正整数，后面每增加 2bit 的长度，能表示的范围都是比它少 2bit 的位数能表示的范围的 4 倍。
    /// 且除了左边第一位，后面每两位都是按照 [10, 11, 00, 01] 的顺序排列来表示连续递增的数字的。
    /// 
    /// 对于每个奇数位数的最大值，都是譬如 1 01 01 ... 01 这样的形式 (和正常的二进制数完全一致，可以直接用数值类型表示)；
    /// 找到第一个 大于等于 n 的 m 位最大值，此时可以直接得到 m 位对应的最小值: 1 10 10 ... 10 (表示为正常的二进制数值也就是对应十进制的 2^(m-1) - 2^(m-2) - 2^(m-4) - .. - 2^1)；
    /// 那么这个奇数位数能表示的范围大小等于 4^(m/2)
    /// </summary>
    /// <param name="n"></param>
    /// <returns></returns>
    public string BaseNeg2(int n) {
        if (0 <= n && n <= 1) return $"{n}";
        var bMax = (1 << 2) + 1;
        var power = 0;
        for (; bMax < n; bMax = (bMax << 2) + 1) { power++; }
        var ans = "1";
        var bMin = 0; // 从右向左累加，把负数加完后再统一取相反数
        for (int i = 0; i <= power; i++) {
            bMin = (bMin << 2) + (1 << 1);
        }
        bMin = (1 << ((power + 1) * 2)) - bMin; 
        var divider = 1 << (power * 2);
        var diff = n - bMin;
        while (power-- >= 0) {
            ans += elements[diff / divider];
            diff %= divider;
            divider >>= 2;
        }
        return ans;
    }

    private readonly string[] elements = ["10", "11", "00", "01"];
}

/**
1 bit (0..1 <delta=2>):
0 -> 0
1 -> 1

3 bit (2..5 <delta=4>):
2  -> 1 10 (6)
3 -> 1 11 (7)
4 -> 1 00
5 -> 1 01

5 bit (6..21 <delta=16>):
min: 6 => 1 10 10 = 16 - 8 - 2 = 6
7 -> 1 10 11 = 16 - 8 - 2 + 1 = 7
8 -> 1 10 00 = 16 - 8 = 8
9 -> 1 10 01 = 16 - 8 + 1 = 9

10 -> 1 11 10 = 16 - 8 + 4 - 2 = 10
11 -> 1 11 11 = 16 - 8 + 4 - 2 + 1 = 11
12 -> 1 11 00 = 16 - 8 + 4 = 12
13 -> 1 11 01

14 -> 1 00 10
15 -> 1 00 11
16 -> 1 00 00
17 -> 1 00 01

18 -> 1 01 10
19 -> 1 01 11
20 -> 1 01 00
max: 1 01 01 = 21

7 bit:
min: 22 -> 1 10 10 10
max: 22 + 4 * 16 - 1 = 85 -> 1 01 01 01 01
<共计 64 个元素>
**/