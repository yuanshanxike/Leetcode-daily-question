namespace L924;

public class Solution {

    private class ConnectedComponent(ushort no, int num) {
        // 连通分量编号
        internal ushort no = no;

        // 包含的节点数
        internal int num = num;
    }

    private readonly Dictionary<int, ConnectedComponent> memory = [];   // 其实这种记忆化递归的实现方式，本质上相当于并查集（visited 中记录的访问过的变量，最后都会和一个我们定义的连通块相关联起来）

    private readonly ISet<int> visited = new HashSet<int>();

    public int MinMalwareSpread(int[][] graph, int[] initial) {
        memory.Clear();
        Array.Sort(initial);  // 先对 initial 进行排序。之后对其中每个节点进行 DFS 时可以保证访问的节点编号顺序是从小到大
        var components = new List<ConnectedComponent>();
        var saveNums = new int[initial.Length];  // 移除其中的每一个节点所能拯救的数量
        ushort lastNo = 0;  // 给联通分量设置的编号
        foreach (var init in initial)
        {
            visited.Clear();
            var component = memory.TryGetValue(init, out var c) ? c : new ConnectedComponent(lastNo, Dfs(graph, init));
            var componentOrNull = components.Find(x => x.no == component.no);
            if (componentOrNull != null)
            {
                componentOrNull.num = 0; // 有多余一个的被感染节点位于相同连通分量中的话，这个连通分量中的节点终会被全部感染，不会有幸免
            } else {
                visited.ToList().ForEach(
                    node => memory[node] = component
                );
                lastNo++;
            }
            components.Add(component);
        }
        var maxNum = -1;
        var ans = -1;
        for (int i = 0; i < initial.Length; i++)
        {
            var c = components[i];
            if (c.num > maxNum) {
                maxNum = c.num;
                ans = initial[i];
            }
        }
        return ans;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="graph"></param>
    /// <param name="start">每次开始进行DFS的入口</param>
    /// <returns>该节点所在连通分量的节点数量（包括自身及未访问的节点）</returns>
    private int Dfs(int[][] graph, int start) {
        // var nextable = AccessableNodes(graph[start], start);
        visited.Add(start);
        var nodeNum = 1; // itself
        var row = graph[start];
        for (int i = 0; i < graph.Length; i++)
        {
            if (i != start && !visited.Contains(i) && row[i] == 1) {
                nodeNum += Dfs(graph, i);
            }
        }
        return nodeNum;
    }

    /*private bool[] nexts;*/  // 这里不能设置成成员变量，因为这样会导致：递归的上层还没有迭代完毕，就被下层的递归把数组中的值给修改了

    // private bool[] AccessableNodes(int[] row, int cur) {
    //     var nexts = new bool[row.Length];
    //     for (int i = 0; i < row.Length; i++)
    //     {
    //         var isAccessable = i != cur && !visited.Contains(i) && row[i] == 1;
    //         nexts[i] = isAccessable;
    //     }
    //     return nexts;
    // }
}